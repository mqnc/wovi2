<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Marching Cubes Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
          "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <script type="module">
        import *as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.up.set(0, 0, 1);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x123456, 1);
        document.body.appendChild(renderer.domElement);

        const loader = new GLTFLoader()
        loader.load(
            "models/ur5e.glb",
            function (gltf) { scene.add(gltf.scene) },
            function (xhr) {
                // console.log((xhr.loaded / xhr.total * 100) + '% loaded')
            },
            function (error) {
                console.error('error loading ' + path)
                reject()
            }
        )

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        const tcp = new THREE.AxesHelper(0.1)
        tcp.position.set(-0.5, -0.1, 0.2)
        scene.add(tcp)
        const gizmo = new TransformControls(camera, renderer.domElement)

        gizmo.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value;
        });
        gizmo.attach(tcp);
        gizmo.setMode("rotate")
        gizmo.space = "local"
        const gizmoHelper = gizmo.getHelper();
        scene.add(gizmoHelper);

        scene.add(new THREE.AxesHelper(1));

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dir = new THREE.DirectionalLight(0xffffff, 1);
        dir.position.set(1, 1, 1);
        scene.add(dir);
        const sun = new THREE.PointLight(0xffffff, 100)
        sun.position.set(4, 5, 6)
        scene.add(sun)

        const geometry = new THREE.BufferGeometry();
        const material1 = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.BackSide, transparent: true, opacity: 0.5 });
        const material2 = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.FrontSide, transparent: true, opacity: 0.5 });
        const mesh1 = new THREE.Mesh(geometry, material1);
        const mesh2 = new THREE.Mesh(geometry, material2);
        scene.add(mesh1);
        scene.add(mesh2);

        const ws = new WebSocket('ws://localhost:8080/ws');
        ws.binaryType = 'arraybuffer';

        ws.onmessage = (ev) => {
            const buf = ev.data;
            const view = new DataView(buf);
            let o = 0;

            const vcount = view.getUint32(o, true); o += 4;
            const icount = view.getUint32(o, true); o += 4;

            const positions = new Float32Array(buf, o, vcount * 3);
            o += vcount * 3 * 4;

            const normals = new Float32Array(buf, o, vcount * 3);
            o += vcount * 3 * 4;

            const indices = new Uint32Array(buf, o, icount);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeBoundingSphere();
        };

        let lastState = ""
        window.setInterval(() => {
            let state = tcp.matrixWorld.clone().transpose().elements.join(",")
            if (state != lastState) {
                ws.send(state)
                lastState = state
            }
        }, 50)

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>